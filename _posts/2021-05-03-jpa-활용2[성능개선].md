---
layout: post
title: JPA 활용[2] 성능개선 - 1
subtitle: 회원 수정, 조회, 등록
gh-repo: daattali/beautiful-jekyll
thumbnail-img: /assets/img/jpa.png
cover-img: /assets/img/natural_design.jpg
tags: [jpa, persistance context]
comments: true
categories: jpa
---

___
## 목표

#### 1. JPA를 사용 시 API 주의점을 공부해보자.
#### 2. API 통신으로 등록 수정 조회 해본다.
___

<br/>

__등록__

[맴버 class(entity)]
~~~java
@Entity
@Getter
@Setter
public class Member {
    @Id @GeneratedValue
    @Column(name = "member_id")
    private Long id;

    private String name;

    @Embedded
    private Address address;

    @OneToMany(mappedBy = "member", fetch = FetchType.LAZY)
    private List<Orders> orders = new ArrayList<>();
}
~~~
이제 member 등록 api 로직을 짜보자.
~~~java
@RestController
@RequiredArgsConstructor
public class MemberApiController {

    private final MemberService memberService;
    /**
     * entity 사용한 회원 등록 api
     * @param member
     * @return
     */
    @PostMapping("/api/vi/members")
    public CreateMemberResponse saveMemberV1(@RequestBody @Valid Member member) {
        //JSON으로 들어온 body를 Member로 쫙 내려줌. => RequestBody
        Long memberId = memberService.join(member);
        return new CreateMemberResponse(memberId);
    }

    @Data
    static class CreateMemberResponse {
        private Long id;

        public CreateMemberResponse(Long memberId) {
            this.id = memberId;
        }
    }
}
~~~
![jpa 그림 - 1](/assets/img/jpaExercise2/회원 등록1 - 실행.png)

> - entity에 직접 접근하여 데이터를 가져온다면 무슨 문제가 발생할까?
> - entity 컬럼 이름을 바꾼다면? api spec도 같이 바뀌게 되는 문제 발생
> - DTO 만들어서 사용
> - entity = 파라미터로 받지도 말고 웹에 노출도 하지마라.

<br/>

~~~java
/**
 * dto 사용한 회원 등록 api
 * @param request
 * @return
 */
 @PostMapping("/api/v2/members")
 public CreateMemberResponse saveMemberV2(@RequestBody @Valid CreateMemberRequest request) {
     Member member = new Member();
     member.setName(request.getName());
     Long memberId = memberService.join(member);
     return new CreateMemberResponse(memberId);
 }

@Data
static class CreateMemberResponse {
    private Long id;

    public CreateMemberResponse(Long memberId) {
        this.id = memberId;
    }
}

@Data
static class CreateMemberRequest{
    @NotEmpty
    private String name;
}
~~~

> - 위 코드는 DTO 적용한 코드이다.
> - 
> 
<br/>


![jpa 그림 - 1](/assets/img/21.04.30-jpa연습4[그림1].png)


~~~java
Member m = em.reference(Member.class, "id1") -> m.getName();
~~~
> - 순서 :
> - -> p.c.에 초기화 요청 -> 1차 캐시에 Member없으면 없을 시 디비에서 데이터 가져와 엔티티 객체 내어줌. -> 프록시 객체가 (내어준)엔티티 객체에 접근하여 데이터 조회함. -> 1차 캐시에 Member있으면 엔티티 객체를 사용하도록 함.
> - m.getName();  :  강제 초기화 
> - JPA는 타입을 동일하게 만들어주는 특성이 있다.
> - 만일 프록시를 써서 조회하는데 준영속 상태라면?? => 에러.! 왜냐, 초기화 요청을 하였는데 p.c.에 도움받을 수 없는 상태라면 에러가 뜨는게 당연!!!
> - JPA에서 객체 타입을 비교할 때는 "==" 쓰지말고 instance.of() 사용 !!!
> - 왜냐, 실무할 때는 파라미터로 프록시와 실제 객체를 보내어 비교 혹은 사용하는데 알 수 있는 방법이 없다.
> - 프록시 인스턴스 초기화 여부 : 엔티티매니저팩토리.getPersistenceUnitUtil.isLoaded(Object obj) 사용
> - 프록시 클래스 확인 : entity.getClass();
> - 프록시 강제 초기화 : m.getName();


__지연로딩과 즉시로딩__
	
> - 지연로딩(Lazy) Member따로 호출 Team따로 호출 가능하다.
> - 즉시로딩(Eager) Member, Team 조인해서 호출, 둘 다 같이 조회 가능 
> - 실무에선 지연로딩만 쓰는게 옳다!! (Eager사용하면 나는 분명 member만 조회했는데 team까지 조회되는 query문이 발생)
> - 또한, JPQL사용 (select m from Member m) 해버리면 JPA가 볼때 select * from member를 쏘지만 엔티티보니깐 Team team이 (Eager네?? Team도 쏴줘야지 근데 타입이 Member라 where로 걸러주는 쿼리뜸 
> - 일단 전부 Lazy로 패치셋팅해주고 만일 Team이랑 같이 써야한다면 join fetch 사용하자 ex) select m from Member m join fetch m.team


__영속성 전이 : CASCADE__
	
> - 프록시, 지연, 즉시로딩과 무관
> - 자식 p.c.에 넣고싶고 부모도 p.c.에 넣고 싶다. 그럼 각각 em.persist(child1), em.persist(child2), em.persist(parent)이다.
> - 자식 엔티티를 부모에서 같이 p.c.관리하고 싶다. em.persist(parent)만 해줘도 child1,2 같이 넣어줄 수 있게.
> - 그럼 Parent.java 엔티티 생성에 => @OneToMany(mappedBy = "parent", cascade = CascadeType.All) 해주면 됨.
> - 근데 소유자가 Parent뿐이면 cascade = CascadeType.All 상관없는데 다른 소유자도 있다면 사용금지.
> - 고아 객체 : 부모 엔티티와 연관관계가 끊어진 자식 엔티티 자동 삭제.   "orphanRemoval = true"
> - 참조하는 곳이 하나일 때 사용해야한다., 특정 엔티티가 개인 소유!
> - cascade와 orphanRemoval를 둘 다 사용시에는 부모 엔티티를 통해서 자식의 생명주기가 관리된다.