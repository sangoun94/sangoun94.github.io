---
layout: post
title: JPA 활용[2] 성능개선 - API개발고급
subtitle: 컬렉션 조회, 부분 fetch 조인
gh-repo: daattali/beautiful-jekyll
thumbnail-img: /assets/img/jpa.png
cover-img: /assets/img/natural_design.jpg
tags: [jpa, API고급, Fetch, DTO, xToMany, 컬렉션]
comments: true
categories: jpa
---

___
## 목표

#### 3. 컬렉션 조회 최적화를 할 수 있다.
___

<br/>

이전 포스터에서 컬렉션 fetch join을 잘 하였지만 페이징 처리가 되지 않는 것을 확인하였다.

페이징 처리를 해결해보자.

| 단계 |
|:---:|
| `엔티티 노출` |
| `DTO 변환` |
| `패치 조인 최적화` |
| `DTO 바로 조회` |

___

__패치 조인 최적화__

~~~java
/**
 * XtoMany 관계 추가 (ManyToOne, OneToOne, OneToMany)
 * Order 조회
 * Orders -> Member 연관   ManyToOne
 * Orders -> Delivery 연관 OneToOne
 * Orders -> OrderItem 연관 OneToMany
 */
@RestController
@RequiredArgsConstructor
public class OrderApiController {

    private final OrderRepositoy orderRepositoy;

    @GetMapping("/api/v3.1/orders")
    public List<OrderDto> ordersV3_page(@RequestParam(value = "offset", defaultValue = "0") int offset,
                                        @RequestParam(value = "limit", defaultValue = "100") int limit) {
        List<Orders> withItem = orderRepositoy.findAllWithMemberDelivery(offset, limit); //페이징에 영향을 주지 않는 놈들 member, delivery
        List<OrderDto> collect = withItem.stream()
                .map(o -> new OrderDto(o))
                .collect(Collectors.toList());

        return collect;
    }
    //DTO는 전전 글에 있으므로 생략한다.
}
~~~

<strong>바뀐 findAllWithMemberDelivery(offset, limit); 이놈은 @xToOne에서 사용하던 놈이다. member와 delivery만 fetch조인한 놈이다.

왜 이렇게 사용하는지 보자. 지금까지 봐온 결과 member, delivery는 ToOne에 해당되므로 페이징 처리가 가능한 놈들이다.

ToMany에 해당되는 놈은 건들이지 않을 생각이다.

나머지 dto변환은 같다.</strong>

~~~java
@Repository
@RequiredArgsConstructor
public class OrderRepositoy {
    private final EntityManager em;
    // fetch 조인
    public List<Orders> findAllWithMemberDelivery(int offset, int limit) {
        return em.createQuery(
                "select o from Orders o " +
                        "join fetch o.member m " +
                        "join fetch o.delivery d", Orders.class)
                .setFirstResult(offset)
                .setMaxResults(limit)
                .getResultList();

    }
}
~~~

> - setFirstResult, setMaxResults 말고는 변화가 없음
> 
<br/>

실행 URL : http://localhost:8080/api/v3.1/orders?offset=1&limit=100

<br/>

~~~json
[
    {
        "orderId": 11,
        "name": "userB",
        "orderDate": "2021-05-06T17:50:52.149618",
        "orderStatus": "ORDER",
        "address": {
            "city": "전주",
            "street": "2",
            "zipcode": "2222"
        },
        "orderItems": [
            {
                "itemName": "SPRING1 BOOK",
                "orderPrice": 20000,
                "count": 3
            },
            {
                "itemName": "SPRING2 BOOK",
                "orderPrice": 40000,
                "count": 4
            }
        ]
    }
]
~~~


~~~sql
select
        distinct orders0_.order_id as order_id1_6_0_,
        member1_.member_id as member_i1_4_1_,
        delivery2_.delivery_id as delivery1_2_2_,
        orderitems3_.order_item_id as order_it1_5_3_,
        item4_.item_id as item_id2_3_4_,
        orders0_.delivery_id as delivery4_6_0_,
        orders0_.member_id as member_i5_6_0_,
        orders0_.order_date as order_da2_6_0_,
        orders0_.status as status3_6_0_,
        member1_.city as city2_4_1_,
        member1_.street as street3_4_1_,
        member1_.zipcode as zipcode4_4_1_,
        member1_.name as name5_4_1_,
        delivery2_.city as city2_2_2_,
        delivery2_.street as street3_2_2_,
        delivery2_.zipcode as zipcode4_2_2_,
        delivery2_.status as status5_2_2_,
        orderitems3_.count as count2_5_3_,
        orderitems3_.item_id as item_id4_5_3_,
        orderitems3_.order_id as order_id5_5_3_,
        orderitems3_.order_price as order_pr3_5_3_,
        orderitems3_.order_id as order_id5_5_0__,
        orderitems3_.order_item_id as order_it1_5_0__,
        item4_.name as name3_3_4_,
        item4_.price as price4_3_4_,
        item4_.stock_quantity as stock_qu5_3_4_,
        item4_.artist as artist6_3_4_,
        item4_.etc as etc7_3_4_,
        item4_.author as author8_3_4_,
        item4_.isbn as isbn9_3_4_,
        item4_.actor as actor10_3_4_,
        item4_.director as directo11_3_4_,
        item4_.dtype as dtype1_3_4_ 
    from
        orders orders0_ 
    inner join
        member member1_ 
            on orders0_.member_id=member1_.member_id 
    inner join
        delivery delivery2_ 
            on orders0_.delivery_id=delivery2_.delivery_id 
    inner join
        order_item orderitems3_ 
            on orders0_.order_id=orderitems3_.order_id 
    inner join
        item item4_ 
            on orderitems3_.item_id=item4_.item_id
~~~

<br/>

이번 패치 조인으로 N + 1 문제는 해결은 되었다. 하지만 페이징 처리가 안되는건 치명적인 단점이다.

이를 해결하는건 다음 글에서 만나보도록하자.