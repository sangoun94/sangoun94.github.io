---
layout: post
title: JPA 활용[2] 성능개선 - API개발고급
subtitle: 컬렉션 조회, 엔티티 노출 조회
gh-repo: daattali/beautiful-jekyll
thumbnail-img: /assets/img/jpa.png
cover-img: /assets/img/natural_design.jpg
tags: [jpa, API고급, DTO]
comments: true
categories: jpa
---

___
## 목표

#### 3. 컬렉션 조회 최적화를 할 수 있다.
___

<br/>

이전까지 @xToOne 을 사용하는 곳에서의 조회 최적화를 진행해보았다. 이번에는 @xToMany 을 사용하는 곳에서의 조회 최적화를 진행해보겠다.(컬렉션 조회 최적화)

| 단계 |
|:---:|
| `엔티티 노출` |
| `DTO 변환` |
| `패치 조인 최적화` |
| `DTO 바로 조회` |

___

__엔티티 노출__

~~~java
/**
 * XtoMany 관계 추가 (ManyToOne, OneToOne, OneToMany)
 * Order 조회
 * Orders -> Member 연관   ManyToOne
 * Orders -> Delivery 연관 OneToOne
 * Orders -> OrderItem 연관 OneToMany
 */
@RestController
@RequiredArgsConstructor
public class OrderApiController {

    private final OrderRepositoy orderRepositoy;

    /**
     * entity 직접 노출. xToOne
     * @return
     */
    @GetMapping("/api/v1/orders")
    public List<Orders> ordersV1() {
        List<Orders> all = orderRepositoy.findAllByString(new OrderSearch());

        for (Orders orders : all) {
            orders.getMember().getName();
            orders.getDelivery().getAddress();
            // 프록시 강제 초기화 해줌.
            // orderItem 컬랙션 출력.
            List<OrderItem> orderItems = orders.getOrderItems();
            orderItems.forEach(o -> o.getItem().getName());
        }
        return all;
    }
}
~~~

> - 전에 포스터에서 설명하였듯이 proxy를 가져와야하기 때문에 찾아온 모든 entity 를 전부 proxy 강제호출해주는 부분이다.
> - 추가된건 orderItems(컬렉션)을 가져와야하는 부분이다.
> - orderItems 또한 proxy 강제 초기화를 진행하였다.
> - orderItems 안에 Item 또한 조회하기 위해서 orderItems 반복문으로 안에있는 item 가져오는 과정이다.
> - orders 에서 member, delivery, orderItems 를 조회하면 양방향관계가 되므로 무한 루프에 빠지게 된다.
> - @JsonIgnore, Hibernate5Module 추가 이유 [xToOne entity](https://sangoun94.github.io/2021-05-03-jpa-%ED%99%9C%EC%9A%A92-2-API%EA%B0%9C%EB%B0%9C%EA%B3%A0%EA%B8%892-%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%85%B8%EC%B6%9C-%EC%A1%B0%ED%9A%8C/)

## 주의사항

> - 절대 entity를 노출시켜서 DB값을 가져오면 안된다.
> - 우리가 데이터를 api spec 에 맞게 제어할 수 없어진다.
> - 


~~~java
@Data
public class OrderSimpleQueryDto {

    private Long orderId;
    private String name;
    private LocalDateTime orderDate;
    private OrderStatus orderStatus;
    private Address address;

    public OrderSimpleQueryDto(Long orderId, String name, LocalDateTime orderDate, OrderStatus orderStatus, Address address) {
        this.orderId = orderId;
        this.name = name;     //Lazy 초기화 시점.
        this.orderDate = orderDate;
        this.orderStatus = orderStatus;
        this.address = address;     //Lazy 초기화 시점.
    }
}
~~~

전에 사용하던 controller안에서의 dto와 다른 건 생성자에 orders를 넣은게 아닌 각 필드마다 매칭시켜준 것 뿐이다.

이제 findOrderDto를 보자.

~~~java
@Repository
@RequiredArgsConstructor
public class OrderRepositoy {
    private final EntityManager em;

    public List<OrderSimpleQueryDto> findOrderDto() {
        return em.createQuery(
                "select new com.jpabook.jpashop.repository.OrderSimpleQueryDto(o.id, m.name, o.orderDate, o.status, d.address) " +
                        "from Orders o " +
                        "join o.member m " +
                        "join o.delivery d", OrderSimpleQueryDto.class).
                getResultList();
    }
}
~~~

> - Repository에 작성
> - List<OrderSimpleQueryDto> 반환,, List<Orders>가 아님
> - select문에서도 dto 생성자를 가져온다.

일단 실행해보자.

~~~json
[
    {
        "orderId": 4,
        "name": "userA",
        "orderDate": "2021-05-04T13:37:02.650656",
        "orderStatus": "ORDER",
        "address": {
            "city": "서울",
            "street": "1",
            "zipcode": "1111"
        }
    },
    {
        "orderId": 11,
        "name": "userB",
        "orderDate": "2021-05-04T13:37:02.717656",
        "orderStatus": "ORDER",
        "address": {
            "city": "전주",
            "street": "2",
            "zipcode": "2222"
        }
    }
]
~~~

실행 결과는 동일하게 출력되었다.

다음 n+1 문제는 어떻게 되었는지 보자.

~~~sql
select
    orders0_.order_id as col_0_0_,
    member1_.name as col_1_0_,
    orders0_.order_date as col_2_0_,
    orders0_.status as col_3_0_,
    delivery2_.city as col_4_0_,
    delivery2_.street as col_4_1_,
    delivery2_.zipcode as col_4_2_ 
from
    orders orders0_ 
inner join
    member member1_ 
        on orders0_.member_id=member1_.member_id 
inner join
    delivery delivery2_ 
        on orders0_.delivery_id=delivery2_.delivery_id
~~~

> - N + 1 문제도 해결되면서 member, delivery의 정보도 잘 빠져서 나옴.
> - SQL 사용하는 것처럼 원하는 값을 선택해서 조회
> - new 명령어 사용, JPQL의 결과가 DTO로 반환
> - select절에 원하는 데이터 조회 가능, 네트웍 용량 최적화 유리(미비)
> - 재사용 떨어짐, API 스펙 바뀌면 못쓰는 코드이다.

근데 이 DTO를 사용하는 방법이 제일 BEST라고 말할 수 있을까? 또, 언제 사용하는게 좋을까?

많은 사용자들이 접근하는 API여서 트래픽이 정말 심할 때 사용하는 것이 옳다. 또한 select 절에서 원하는 컬럼들이 50,100개 이렇게 많아질 때 사용하는 게 좋다. 재사용성이 거의 없어서 픽스된 API SPEC 에서 장점을 갖는다.

<br/>

###### 마지막으로 쿼리 방식 권장 순서 정리하고 마치겠다.

> - 쿼리 방식 선택 권장 순서
> - 1. 우선 엔티티를 DTO로 변환하는 방법을 선택한다.
> - 2. 필요하면 페치 조인으로 성능을 최적화 한다. 대부분의 성능 이슈가 해결된다.
> - 3. 그래도 안되면 DTO로 직접 조회하는 방법을 사용한다.
> - 4. 최후의 방법은 JPA가 제공하는 네이티브 SQL이나 스프링 JDBC Template을 사용해서 SQL을 직접

